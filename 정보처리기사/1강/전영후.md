# JAVA

### 1. [객체지향 프로그래밍](#1-객체지향-프로그래밍-1)
### 2. [JVM](#2-JVM-1)

<br>

## 1. 객체지향 프로그래밍

* ### 객체지향이란..
   객체지향 프로그래밍은 소프트웨어를 개발하는 프로그래밍 패러다임 중 하나로 상태(Field)와 행위(Method)로 이루어진<br>객체들간의 상호작용을 기반으로 프로그램을 설계 및 개발하는 것입니다. 

<br>

* ### 객체지향의 장점
<h4>
 <ol>
  <li>코드 재사용성</li>
  <li>유지보수성</li>
  <li>확장성</li>
  <li>정보 은닉</li>
 </ol>
</h4>

<br>

### JAVA의 객체지향 특징

* **클래스 (Class)**
   * 객체를 정의하는 틀이며 필드와 메소드로 구성됩니다. 클래스는 여러 객체를 생성하기 위한 설계도로 생각할 수 있습니다.
```JAVA
class Car {
    // 필드
    String name;
    int speed;

    // 메소드
    public void move() {}

}
```
<br>

* **객체 (Object)**
  * 객체는 클래스의 인스턴스로 실제로 메모리에 할당된 데이터입니다. 객체는 클래스에서 정의한 필드와 메소드를 가집니다.
```JAVA

Car car = new Car(); // new 연산자를 통해 클래스 타입의 인스턴스 생성 및 참조값 Return
car.move();

```
<br>

* **상속 (Inheritance)**
  * 상속은 부모 클래스의 특성을 자식 클래스가 물려받는 개념입니다. 코드의 재사용성을 높이고 계층 구조를 형성하여<br>유지보수성을 개선합니다.
```JAVA

public class Main {
        public static void main(String[] args) {

            SUV suv = new SUV();
            suv.시동();

        }
}

class Car {
    public void 시동() {
        System.out.println("시동을 겁니다.");
    }
}

class SUV extends Car {

    String name;
    int speed;

}

```

<br>

* **다형성 (Polymorphism)**
  *  다형성이란 서로 다른 타입의 객체를 동일한 인터페이스나 부모 클래스를 사용하여 통일적으로 다룰 수 있는 개념으로<br>코드의 유연성과 확장성을 높입니다.

```JAVA
public class Main {
        public static void main(String[] args) {

            Car suv = new SUV(); // 업캐스팅을 통해
            Car van = new VAN(); // 부모 타입 변수에 자식 인스턴스 전달

            suv.시동();
            van.시동();

        }
}

class Car {
    public void 시동() {
        System.out.println("시동을 겁니다.");
    }
}

class SUV extends Car {

    String name;
    int speed;

    @Override
    public void 시동() {
        System.out.println("SUV 시동을 겁니다.");
    }

    public void 시동(String name) {
        System.out.println(name);
    }

}

class VAN extends Car {

    String name;
    int speed;

    @Override
    public void 시동() {
        System.out.println("VAN 시동을 겁니다.");
    }

    public void 시동(String name) {
        System.out.println(name);
    }

}
```
<br>

* **캡슐화 (Encapsulation)**
  * 데이터와 그 데이터를 다루는 메서드들을 하나로 묶고 외부에서 직접적인 접근을 제한하는 것을 의미합니다.<br>이를 통해 객체 상태를 은닉하고 외부에서는 객체의 행동만을 노출시킴으로써 정보 은닉과 결합도를 낮춰 확장성을 높일 수 있습니다.
 
```JAVA
public class Main {
        public static void main(String[] args) {

            SUV suv = new SUV();
            VAN van = new VAN();

            // set메소드를 데이터에 간접적으로 접근
            suv.setName("SUV");
            van.setName("VAN");

            suv.시동();
            van.시동();

        }
}

class Car {
    public void 시동() {
        System.out.println("시동을 겁니다.");
    }
}

class SUV extends Car {

    private String name; // private으로 접근 제한
    private int speed; // private으로 접근 제한

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public void 시동() {
        System.out.println(name + " 시동을 겁니다.");
    }

}

class VAN extends Car {

    private String name; // private으로 접근 제한
    private int speed; // private으로 접근 제한

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public void 시동() {
        System.out.println(name + " 시동을 겁니다.");
    }

}
```
<br>

* **추상화 (Abstraction)**
   * 추상화는 객체의 공통적인 특성을 추출하여 인터페이스나 추상 클래스로 정의하는 것을 말합니다.<br>추상화를 통해 객체의 복잡한 내부 구현을 숨기고 객체 간의 관계를 단순화하며 가독성을 높일 수 있습니다.


```JAVA
public class Main {
        public static void main(String[] args) {

            SUV suv = new SUV();
            VAN van = new VAN();

            suv.충전();
            van.충전();

        }
}

abstract class Car {

    abstract void 충전(); // 공통된 특성 정의

}

class SUV extends Car {

    private String name;
    private int speed;

    @Override
    void 충전() {
        System.out.println("전기를 이용해 충전합니다.");
    }

}

class VAN extends Car {

    private String name;
    private int speed;

    @Override
    void 충전() {
        System.out.println("휘발유를 이용해 충전합니다.");
    }
}
```
<br>

## 2. JVM

### 자바는 운영체제에 왜 독립적인가
https://velog.io/@sgwon1996/JAVA%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC%EC%99%80-JVM-%EA%B5%AC%EC%A1%B0
https://cjw-awdsd.tistory.com/26#google_vignette









---

상속
부모 클래스의 특성을 넘겨 받아 재사용이 가능

다형성
업캐스팅을 통해 부모타입의 자식인스턴스 참조변수 생성 가능
왜쓰냐 오버라이딩을 이용하여 다형성 증가
오버라이딩 같은 경우 컴파일이 된 후 메소드 호출 과정에서 동적 바인딩으로 인해 가능
하지만 해당 타입에 없는 메소드일 경우 컴파일 단계에서 오류
또한 오버로드를 통해 자식클래스에 동일한 메소드 생성 가능

캡슐화
객체의 속성과 행위를 묶어 높은 응집도를 통해 코드의 결합도를 낮출 수 있으며
외부에서의 데이터 접근을 제한하기에 정보 은닉을 통해 안정성을 높일 수있다


추상화
공통된 특징을 찾아 추상화로 정의하여 내부적인 복잡한 로직을 제외하고 원하는 결과를 받기에 용이하다
대표적 JPA(java persistence api


